# Инвариант цикла. Расширенный алгоритм Евклида вычисления НОД
Алгоритм, подобный алгоритму Евклида, который наряду с НОД(a,b) вычисляет также 
и целые числа u,v такие что НОД(a,b) = ua+vb, называется расширенным алгоритмом 
Евклида.
Для проектирования этого алгоритма применим метод инварианта цикла.
# m, n - заданные целые
a, b = m, n
u_a, v_a = 1, 0
u_b, v_b = 0, 1
#=
ИНВАРИАНТ: 
НОД(m,n)==НОД(a,b)
a = u_a*m + v_a*n 
b = u_b*m + v_b*n
=#
while b != 0
k = a÷b
a, b = b, a % b 
#УТВ: a % b = a-k*b - остаток от деления a на b
u, v = u_a, v_a
u_a, v_a = u_b, u_a
u_b, v_b = u-k*u_b, v-k*v_b
end
#УТВ: b == НОД(m,m) == u_a*m + v_a*n
Практическая важность расширенного алгоритма Евклида состоит в том, что с его 
помощью можно находить обратные элементы в кольце вычетов по модулю n.
На каждом шаге расширенного алгоритма Евклида требуется вычислять частное и 
остаток от деления целых чисел. Однако в языке Julia имеется встроенная функции
divrem позволяющая получать и частное и остаток всего за одну операцию. С 
использование этой функции следующие строчки кода с двумя операциями % и ÷
k = a÷b
a, b = b, a % b
могут быть заменены на код с одной единственной операцией divrem следующим 
образом:
k, r = divrem(a,b)
a, b = b, r
В приведенном варианте расширеннного алгоротитма Евклида, также как и в 
рассмотренном выше простом алгоритме Евклида, не учтена возможность 
отрицательных значений чисел a, b. Но это очень легко поправить, только теперь, если 
понадобится изменять знак полученного наибольшего (по модулю) общего делителя с 
отрицательного на положительный, одновременно с этим должны изменяться знаки и 
коэффициентов u_a, v_a.


